### RPC的简化版原理如下图（核心是代理机制）。

![](./img/20240309/2024-03-09_133429.png)

- 1.本地代理存根: Stub
- 2.本地序列化反序列化
- 3.网络通信
- 4.远程序列化反序列化
- 5.远程服务存根: Skeleton
- 6.调用实际业务服务
- 7.原路返回服务结果
- 8.返回给本地调用方

注意处理异常。

### RpcProvider的本地实现

#### 1、工程结构

- rpc-core是核心实现类
- rpc-demo-api是定义实际业务服务的接口
- rpc-demo-provider是业务接口实现类

![](./img/20240309/2024-03-09_140225.png)

#### 2、RpcProvider在启动过程中把@RpcProvider标记的方法存到Map中去
在启动时加载配置
![](./img/20240309/2024-03-09_134522.png)

在配置中创建启动类
![](./img/20240309/2024-03-09_134613.png)

启动类在创建的过程，会将带有@RpcProvider注解的类存放到Map中。
@PostConstruct注解可以在bean的初始化后进行执行，刚好满足我们的常见（存储bean）
使用 ApplicationContextAware接口是为了获取Spring的应用上下文ApplicationContext，从里面获取bean。
![](./img/20240309/2024-03-09_134653.png)

RpcProvider是自定义的一个注解，用来表示这个类是一个服务提供者。
![](./img/20240309/2024-03-09_135223.png)

一个服务提供者，订单服务实现类。
![](./img/20240309/2024-03-09_135326.png)

#### 3、在调用的时候通过方法名称找到应该调用的方法，通过反射完成调用。
发起一个http请求调用，获取订单信息。
![](./img/20240309/2024-03-09_135408.png)

RpcRequest封装请求参数，包括：接口名称、方法名、参数。
![](./img/20240309/2024-03-09_135919.png)


一个请求入口

![](./img/20240309/2024-03-09_135500.png)


请求调用，根据服务全限定名（就是一个类的全名）去map存找对应的类，找到后，通过反射发起方法调用。
![](./img/20240309/2024-03-09_135611.png)

响应类RpcResponse统一封装结果，返回状态，响应结果数据。
![](./img/20240309/2024-03-09_135811.png)


实际的调用结果，就成功了。
![](./img/20240309/2024-03-09_140107.png)


#### 4、有哪些问题？
如果一个接口有多个实现类怎么办？
错误消息怎么处理？
方法有多个重载方法怎么办？

工程地址：https://github.com/midnight2104/midnight-rpc